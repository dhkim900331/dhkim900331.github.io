I"C4<h2 id="1-개요">1. 개요</h2>

<p>RHCSA 과정을 준비하면서, Storage 파티셔닝을 정리한다.</p>

<p>fdisk, gdisk 를 먼저 공부했지만, parted 가 너무 편리하여 parted로 정리한다.</p>

<h2 id="2-mbr--gpt">2. MBR / GPT</h2>

<p>MBR과 GPT의 차이점 등은 다른 구글링으로 쉽게 찾아볼 수 있다.</p>

<p>아래 Section 실습에서는 MBR 이든 GPT이든 mklabel 에서만 지정하면 된다.</p>

<blockquote>
  <p>예시</p>

  <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre>parted /dev/vdb mklabel msdos <span class="c"># MBR</span>
parted /dev/vdb mklabel gpt <span class="c"># GPT</span>
</pre></td></tr></tbody></table></code></pre></div>  </div>

  <p><em>너무 편리하다..</em></p>
</blockquote>

<h2 id="3-gpt-파티셔닝">3. GPT 파티셔닝</h2>

<blockquote>
  <p>MBR 파티셔닝은 msdos 로 label 만 주면 되므로, GPT 로 설명한다.</p>
</blockquote>

<h3 id="31-사용-가능한-디스크-확인">3.1 사용 가능한 디스크 확인</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre><span class="c"># lsblk --fs</span>
NAME   FSTYPE LABEL UUID                                 MOUNTPOINT
vda                                                     
├─vda1                                                  
├─vda2 vfat         399C-0F7D                            /boot/efi
└─vda3 xfs    root  3cd0d4ca-93f6-423b-a469-70ab2b10b667 /
vdb                                                     
vdc                                                     
vdd
</pre></td></tr></tbody></table></code></pre></div></div>

<blockquote>
  <p>새로운 디스크(HDD or SDD 등)를 붙이면 /dev/vd{a~…z} 으로 추가 된다.</p>
</blockquote>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre><span class="c"># parted /dev/vdb print</span>
Error: /dev/vdb: unrecognised disk label
Model: Virtio Block Device <span class="o">(</span>virtblk<span class="o">)</span>                                     
Disk /dev/vdb: 5369MB
Sector size <span class="o">(</span>logical/physical<span class="o">)</span>: 512B/512B
Partition Table: unknown
Disk Flags: 
</pre></td></tr></tbody></table></code></pre></div></div>

<blockquote>
  <p>/dev/vdb 를 확인해보니 disk label 이 없다는 error와, Partion table이 unknown 이라는 것이 확인된다.</p>
</blockquote>

<h3 id="32-디스크-라벨링">3.2 디스크 라벨링</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre># parted /dev/vdb mklabel gpt
Information: You may need to update /etc/fstab.
</pre></td></tr></tbody></table></code></pre></div></div>

<blockquote>
  <p>/dev/vdb 디스크를 GPT 라벨링</p>

  <p><em>MBR일 경우 gpt -&gt; msdos</em></p>
</blockquote>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre><span class="c"># parted /dev/vdb print                                  </span>
Model: Virtio Block Device <span class="o">(</span>virtblk<span class="o">)</span>
Disk /dev/vdb: 5369MB
Sector size <span class="o">(</span>logical/physical<span class="o">)</span>: 512B/512B
Partition Table: gpt
Disk Flags:

Number  Start  End  Size  File system  Name  Flags

</pre></td></tr></tbody></table></code></pre></div></div>

<blockquote>
  <p>print 명령으로 GPT 라벨링 여부도 확인된다.</p>
</blockquote>

<h3 id="33-파티션-생성">3.3 파티션 생성</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre><span class="c"># parted /dev/vdb mkpart backup xfs 1s 2GB</span>
Warning: You requested a partition from 512B to 2000MB <span class="o">(</span>sectors 1..3906250<span class="o">)</span><span class="nb">.</span>
The closest location we can manage is 17.4kB to 2000MB <span class="o">(</span>sectors 34..3906250<span class="o">)</span><span class="nb">.</span>
Is this still acceptable to you?
Yes/No? Yes                                                              
Warning: The resulting partition is not properly aligned <span class="k">for </span>best performance:
34s % 2048s <span class="o">!=</span> 0s
Ignore/Cancel? Ignore                                                    
Information: You may need to update /etc/fstab.
</pre></td></tr></tbody></table></code></pre></div></div>

<blockquote>
  <p>/dev/vdb 에 최초 파티션을 생성하엿다.</p>

  <p><em>파티션 명: backup</em></p>

  <p><strong>파티션 타입: xfs</strong></p>

  <p><em>파티션 크기: 2GB</em></p>

  <p>​	<em>ㄴ최초 파티션이므로, 가장 최소단위 1Sector 부터 2GB 까지 설정)</em></p>

  <p>​	_ㄴ”3.2” 에서 Sector size 를 알 수 있다.__</p>

  <p><em>_MBR일 경우 backup -&gt; primary(경우에 따라 extended)</em></p>
</blockquote>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre><span class="c"># parted /dev/vdb print                                  </span>
Model: Virtio Block Device <span class="o">(</span>virtblk<span class="o">)</span>
Disk /dev/vdb: 5369MB
Sector size <span class="o">(</span>logical/physical<span class="o">)</span>: 512B/512B
Partition Table: gpt
Disk Flags:

Number  Start   End     Size    File system  Name    Flags
 1      17.4kB  2000MB  2000MB               backup 
</pre></td></tr></tbody></table></code></pre></div></div>

<blockquote>
  <p>print의 결과를 보면, 원하는 대로 생성되어 있다.</p>

  <p><em>1s = 512B 라 예상되지만, 시스템은 최소 크기가 17.4kB 인듯 하다</em></p>
</blockquote>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="rouge-code"><pre><span class="c"># mkfs.xfs /dev/vdb1</span>
meta-data<span class="o">=</span>/dev/vdb1              <span class="nv">isize</span><span class="o">=</span>512    <span class="nv">agcount</span><span class="o">=</span>4, <span class="nv">agsize</span><span class="o">=</span>122070 blks
         <span class="o">=</span>                       <span class="nv">sectsz</span><span class="o">=</span>512   <span class="nv">attr</span><span class="o">=</span>2, <span class="nv">projid32bit</span><span class="o">=</span>1
         <span class="o">=</span>                       <span class="nv">crc</span><span class="o">=</span>1        <span class="nv">finobt</span><span class="o">=</span>1, <span class="nv">sparse</span><span class="o">=</span>1, <span class="nv">rmapbt</span><span class="o">=</span>0
         <span class="o">=</span>                       <span class="nv">reflink</span><span class="o">=</span>1
data     <span class="o">=</span>                       <span class="nv">bsize</span><span class="o">=</span>4096   <span class="nv">blocks</span><span class="o">=</span>488277, <span class="nv">imaxpct</span><span class="o">=</span>25
         <span class="o">=</span>                       <span class="nv">sunit</span><span class="o">=</span>0      <span class="nv">swidth</span><span class="o">=</span>0 blks
naming   <span class="o">=</span>version 2              <span class="nv">bsize</span><span class="o">=</span>4096   ascii-ci<span class="o">=</span>0, <span class="nv">ftype</span><span class="o">=</span>1
log      <span class="o">=</span>internal log           <span class="nv">bsize</span><span class="o">=</span>4096   <span class="nv">blocks</span><span class="o">=</span>2560, <span class="nv">version</span><span class="o">=</span>2
         <span class="o">=</span>                       <span class="nv">sectsz</span><span class="o">=</span>512   <span class="nv">sunit</span><span class="o">=</span>0 blks, lazy-count<span class="o">=</span>1
realtime <span class="o">=</span>none                   <span class="nv">extsz</span><span class="o">=</span>4096   <span class="nv">blocks</span><span class="o">=</span>0, <span class="nv">rtextents</span><span class="o">=</span>0

<span class="c"># parted /dev/vdb print</span>
Model: Virtio Block Device <span class="o">(</span>virtblk<span class="o">)</span>
Disk /dev/vdb: 5369MB
Sector size <span class="o">(</span>logical/physical<span class="o">)</span>: 512B/512B
Partition Table: gpt
Disk Flags:

Number  Start   End     Size    File system  Name    Flags
 1      17.4kB  2000MB  2000MB  xfs          backup
</pre></td></tr></tbody></table></code></pre></div></div>

<blockquote>
  <p>파티션의 파일 시스템 유형을 xfs로 선언하고 print로 확인한 모습</p>
</blockquote>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="c"># udevadm settle</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<blockquote>
  <p>/dev/vda1 장치가 준비되는 것을 기다려주는 명령어
원래 윗부분(mkfs)보다 일찍 사용해야 하는데.. 자꾸 이렇게 외워버렸다.</p>
</blockquote>

<h3 id="34-파일시스템-마운트">3.4 파일시스템 마운트</h3>

<p>실제 디렉토리로 마운트 지점을 할당해야 쓸 수 있다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="c"># mkdir /backup</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<blockquote>
  <p>마운트 지점 디렉토리를 생성한다.</p>
</blockquote>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre><span class="c"># lsblk --fs</span>
NAME   FSTYPE LABEL UUID                                 MOUNTPOINT
vda                                                     
├─vda1                                                  
├─vda2 vfat         399C-0F7D                            /boot/efi
└─vda3 xfs    root  3cd0d4ca-93f6-423b-a469-70ab2b10b667 /
vdb                                                     
└─vdb1 xfs          3b1e73fa-409b-459c-aeaf-8866cef00f32
vdc                                                     
vdd       
</pre></td></tr></tbody></table></code></pre></div></div>

<blockquote>
  <p>/dev/vdb1 파티션의 UUID를 확인한다.</p>
</blockquote>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="nv">UUID</span><span class="o">=</span>3b1e73fa-409b-459c-aeaf-8866cef00f32 /backup xfs defaults 0 0
</pre></td></tr></tbody></table></code></pre></div></div>

<blockquote>
  <p>/etc/fstab 파일에 위 내용을 추가한다.</p>
</blockquote>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="c"># systemctl daemon-reload </span>
</pre></td></tr></tbody></table></code></pre></div></div>

<blockquote>
  <p>/etc/fstab 파일을 시스템이 다시 읽도록 한다.</p>
</blockquote>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="c"># mount /backup</span>
<span class="c"># mount | grep vdb1</span>
/dev/vdb1 on /backup <span class="nb">type </span>xfs <span class="o">(</span>rw,relatime,seclabel,attr2,inode64,noquota<span class="o">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<blockquote>
  <p>실제 mount 가 되도록 하고, 잘 되었는지 확인하는 모습
이제 <em>systemctl reboot</em> 으로 재부팅하여도 mount가 항상 되어있다.</p>
</blockquote>
:ET